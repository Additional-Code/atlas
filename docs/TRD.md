# Technical Requirements Document (TRD)

## Architecture

### Layers
- **Transport Layer**
  - REST API via Echo.
  - gRPC API with interceptors.
  - Middleware for auth, logging, tracing.

- **Service Layer**
  - Business logic modules.
  - Auth, RBAC, domain-specific services.

- **Repository Layer**
  - Bun ORM for relational DBs.
  - Redis client for caching.
  - Abstraction for read/write DB pools.

- **Messaging & Workers**
  - Kafka consumer/producer module.
  - Unified Pub/Sub interface.
  - Worker engine with retry, backoff, and dead-letter queue.
  - Fx lifecycle hooks to start/stop workers.

- **Infrastructure Layer**
  - Fx modules for Logger, Tracer, Config, Server, DB, Cache, Messaging.
  - CLI commands wired via Fx.

## Dependency Injection
- Modules: `LoggerModule`, `TracerModule`, `DatabaseModule`, `CacheModule`, `AuthModule`, `ServerModule`, `GrpcModule`, `MessagingModule`, `WorkerModule`.
- Lifecycle management of all external connections.
- Configurable via env + config file.

## Database
- Bun ORM for SQL queries.
- Read/write DSN configuration.
- Migrations via CLI.
- Repository pattern with generics.

## Redis
- Client abstraction for caching, pub-sub, session store.
- Pluggable into Fx.
- TTL policies configurable per use-case.

## Messaging & Workers
- **Kafka**
  - Producer abstraction with delivery guarantees.
  - Consumer group management.
  - Configurable retries, backoff, and DLQ.

- **Pub/Sub**
  - Unified interface for Redis streams, Kafka topics, and Google Pub/Sub.
  - Module selection via config.

- **Worker Engine**
  - Job runner with retry logic.
  - Delayed and scheduled jobs.
  - Standalone worker CLI: `atlas worker run`.
  - Metrics and tracing for job execution.

## gRPC
- gRPC server with Fx lifecycle.
- Interceptors for logging, tracing, auth.
- Reflection enabled for dev.
- Autogenerated gRPC gateway for HTTP/JSON bridging.
- Protobuf definitions compiled with buf.

## Observability
- Zap logger with request/job IDs.
- OpenTelemetry integrated with Echo, gRPC, DB, Redis, Kafka.
- `/metrics`, `/health`, `/ready` endpoints.
- Traces exportable to Jaeger, Tempo, or OTEL collector.

## Tooling
- **CLI (`atlas`)**
  - `atlas migrate up/down`
  - `atlas seed run`
  - `atlas module create <name>`
  - `atlas grpc create <service>`
  - `atlas worker run`
  - `atlas cache flush`
  - `atlas test`

- **DX Enhancements**
  - Swagger/OpenAPI auto-generation from Echo routes.
  - gRPC server reflection + auto docs via buf.
  - Devcontainer + hot reload for seamless local dev.
  - Git hooks for lint/test enforcement.

## Deployment
- Multi-stage Dockerfile.
- docker-compose for local DB/Redis/Kafka.
- Helm chart with services, deployments, jobs.
- GitHub Actions templates (lint, build, test, deploy).

## Testing
- Unit tests with mocks.
- Integration tests with testcontainers for DB/Redis/Kafka.
- E2E tests with OpenAPI and gRPC clients.
- CI integration for coverage and regression checks.

## Example Developer Workflow
1. Clone repo, run `make dev` → starts Echo, gRPC, Kafka, Redis, DB locally.
2. Run `atlas module create orders` → scaffolds REST, gRPC, DB repo, migration, worker.
3. Run `atlas migrate up` → applies DB schema.
4. Run `atlas grpc create PaymentService` → generates proto + service skeleton.
5. Start a worker via `atlas worker run --queue=payments`.
6. Push to repo → CI runs tests, builds images, deploys to Kubernetes.
7. Monitor logs via Zap, traces in Jaeger, metrics in Prometheus.
